import json
import os
import subprocess
import sys
import time
import traceback

from ppadb.client import Client as AdbClient
from prompt_toolkit import prompt as input
import subprocess as sub

# integrated = True
# !#!#!
# This uses pure
# a device that's plugged in via usb
#
# REQUIRED OPTIONS
# DURATION: Time to record screen
# !#!#!


installation = f'{os.getenv("HOME")}/.SuperSploit'
path_to_database = f"{installation}/.data/data.json"
with open(f"{installation}/.data/Aliases.json") as file:
    aliases = json.load(file)
    file.close()

# Default is "127.0.0.1" and 5037
client = AdbClient(host="127.0.0.1", port=5037)
devices = client.devices()
serials = []


class RemoteConnect:
    def ip(self):
        ipp = []
        for device in devices:
            try:
                devicesInfo = str(device.shell('ip addr | grep "wlan0"')).split('\n')
                ipp.append(str(devicesInfo[1].split(' ')[5].split("/")[0]))
            except Exception:
                ipp.append(str(device.get_serial_no()))
                pass
        return ipp

    # Connect to discovered device
    @classmethod
    def adb_connect(cls, device):
        ipp = cls().ip()
        if len(ipp) < 1:
            print("no connected devices")
            return
        for x in ipp:
            print(f"{ipp.index(x)}: {x}")
        inn = input(f"please pick a device: ")
        sub.run(['adb', "-s", f"{devices[int(inn)].get_serial_no()}", 'tcpip', '5555'])
        time.sleep(2)
        print("\033[H\033[J")
        sub.run([f'adb', 'connect', f'{ipp[int(inn)]}:5555'])


class Input_fixes:
    def __init__(self, dataList: list):
        self.list = dataList
        ListOfFixes = [self.cd, self.clear, self.exit]
        fixes = ["cd", "clear", "exit"]
        ListOfFixes[fixes.index(dataList[0])]()
        return

    @staticmethod
    def exit():
        sys.exit()

    def cd(self) -> int:
        os.chdir(self.list[1])
        return 0

    @staticmethod
    def clear():
        sys.stdout.write("\033[H\033[J")


class DatabaseManagment:

    def __init__(self):
        pass

    @classmethod
    def findShells(cls):
        shells = []
        with open("/etc/shells") as file:
            data = file.read().split("\n")
            file.close()
            for x in data:
                try:
                    shells.append(x.split("/")[2])
                except Exception:
                    pass
            return shells

    @classmethod
    def checkIntegration(cls) -> bool:
        with open(DatabaseManagment.get()["EXPLOIT"]) as file:
            data = file.read()
            file.close()
        if "integrated = True" in data:
            return True
        return False

    @classmethod
    def socketedExploit(cls):
        with open(DatabaseManagment.get()["EXPLOIT"]) as file:
            data = file.read()
            file.close()
        if "import socket" in data or "from socket import" in data:
            return True
        return False

    @classmethod
    def addVariableToDatabase(cls, data):
        if os.path.lexists(path_to_database):
            with open(path_to_database) as file:
                database = json.load(file)
                file.close()
            database[data.split(" ")[1]] = data.split(" ")[2]
            with open(path_to_database, "w") as file:
                file.write(json.dumps(database))

    @classmethod
    def findTerm(cls):
        term = None
        with open(f"{installation}/.data/.terminals", "r") as file:
            terms = file.read().split("\n")
            file.close()
        for x in terms:
            if x in os.listdir("/bin"):
                term = x
        return term

    @classmethod
    def directlyModify(cls, data: list):
        try:
            with open(f"{installation}/.data/data.json") as file:
                variables = json.load(file)
                file.close()
            if "exploit" in data[0]:
                variables["EXPLOIT"] = data[1]
            if "payload" in data[0]:
                variables["PAYLOAD"] = data[1]
            if "target" in data[0]:
                variables["R_HOST"] = data[1]
            with open(f"{installation}/.data/data.json", "w") as file:
                file.write(json.dumps(variables))
                file.close()
        except Exception:
            print(traceback.format_exc())
            return

    @classmethod
    def get(cls):
        if os.path.lexists(path_to_database):
            with open(path_to_database) as file:
                data = json.load(file)
                file.close()
            return data

    @staticmethod
    def getExploits():
        exploits = []
        for x in os.listdir(f"{installation}/exploits/"):
            for i in os.listdir(f"{installation}/exploits/{x}"):
                exploits.append(f"{installation}/exploits/{x}/{i}")
        return exploits

    @staticmethod
    def getPayloads():
        exploits = []
        for x in os.listdir(f"{installation}/payloads/"):
            for i in os.listdir(f"{installation}/payloads/{x}"):
                exploits.append(f"{installation}/payloads/{x}/{i}")
        return exploits


class IMPORTS:
    def __init__(self):
        return

    @classmethod
    def findShells(cls):
        shells = []
        with open("/etc/shells") as file:
            data = file.read().split("\n")
            file.close()
            for x in data:
                try:
                    shells.append(x.split("/")[2])
                except Exception:
                    pass
            return shells

    @classmethod
    def Error(cls, data):
        write = sys.stdout.write
        """Error Handling Method prints to stdout and writes to 'installation_dictionary/.data/.errors/error.log'"""
        try:
            if "str" not in str(type(data)):
                try:
                    data = data.decode()
                    pass
                except Exception:
                    data = f"{str(data)}"
                    pass
            if not data.endswith("\n"):
                data = f"{data}\n"
            with open(f"{installation}/.data/.errors/error.log", "a") as stdout:
                stdout.write(data)
                stdout.close()
            write(data)
            return
        except Exception as e:
            write(str(e))

    @classmethod
    def sys_call_other(cls, data):
        try:
            cmd = subprocess.Popen(data.split(" "), stdout=subprocess.PIPE, stdin=subprocess.PIPE,
                                   stderr=subprocess.PIPE)
            output = cmd.communicate()[0], cmd.communicate()[2]
            for x in output:
                if len(x) > 0:
                    sys.stdout.write(x.decode())
                return True
        except Exception:
            cls.Error(traceback.format_exc())
            return False

    @classmethod
    def sys_call_Linux(cls, data):
        shells = cls.findShells()
        if data in shells:
            subprocess.run([f"/usr/bin/{data}"])
        dataList = data.split(' ')
        with open(f"{installation}/.data/Aliases.json") as file:
            Aliases = json.load(file)
            file.close()
        for k, v in Aliases.items():
            if k in dataList:
                dataList[dataList.index(k)] = v
        try:
            if "help" in dataList:
                return
            subprocess.run(dataList)
            return True
        except Exception:
            cls.Error(traceback.format_exc())
            return False

    @staticmethod
    def shells(ars):
        with open('/etc/shells') as file:
            print(file.read())
            file.close()

    @staticmethod
    def show(data):
        if len(data.split(" ")) < 2:
            for k, v in DatabaseManagment.get().items():
                print(f"{k}: {v}")
            return
        elif "details" in data.split(" ")[1]:
            return
        elif len(data.split(' ')) > 1:
            for x in data.split(" "):
                if data.split(" ").index(x) > 0:
                    for k, v in DatabaseManagment.get().items():
                        if data.split(' ')[data.split(" ").index(x)] == k:
                            print(f"{k}: {v}")
            return
        else:
            return

    @classmethod
    def set(cls, data):
        try:
            if len(data.split(" ")) < 2:
                cls.Error("No arguments supplied for set\n")
                return
            data = data.split(" ")
            with open(f"{installation}/.data/data.json") as file:
                variables = json.load(file)
                file.close()
            for k, v in variables.items():
                if data[1] == k:
                    if data[2] == "true":
                        data[2] = True
                    if data[2] == 'false':
                        data[2] = False
                    variables[k] = data[2]
            with open(f"{installation}/.data/data.json", "w") as file:
                file.write(json.dumps(variables))
                file.close()
        except Exception:
            cls.Error(traceback.format_exc())
            return

    @classmethod
    def check(cls, data):
        dataList = data.split(" ")
        for k, v in aliases.items():
            if k in data.split(" "):
                dataList = data.split(' ')[0:len(data.split(" ")) - 1]
                dataList.append(v)
        inputFixList = ["cd", "clear", "exit"]
        try:
            if dataList[0] in inputFixList:
                Input_fixes(dataList)
                return
            if len(dataList) == 1:
                if dataList[0] == '':
                    return
            if data.endswith(" "):
                data = data.lstrip(" ")
            functions = [cls.show, cls.set]
            inputs = ["show", "set"]
            try:
                if data.split(" ")[0] in inputs:
                    functions[inputs.index(data.split(" ")[0])](data)
                    return
                if "Linux" in os.uname():
                    cls.sys_call_Linux(data)
                    return
                cls.sys_call_other(data)
            except Exception:
                cls.Error(traceback.format_exc())
        except Exception:
            cls.Error(traceback.format_exc())


class ADBINTERFACE:
    def __init__(self):
        return

    @staticmethod
    def screenshot(client):
        client.shell("screencap -p /sdcard/screenshot.png")
        return True

    @staticmethod
    def push(device):
        print("Location: .data/.adb/")
        files = os.listdir(".data/.adb")
        for x in files:
            print(f"{files.index(x)}: {x}")
        i = input("Enter the index of the file to push: ")
        try:
            i = int(i)
            device.push(f"{installation}/.data/.adb/{files[i]}", "/sdcard/Download/")
        except ValueError:
            sys.stderr.write("Please enter the index.")

    @staticmethod
    def takePic(device):
        device.shell("am start -a android.media.action.IMAGE_CAPTURE")
        device.shell("input keyevent KEYCODE_FOCUS")
        time.sleep(.1)
        device.shell("input keyevent KEYCODE_CAMERA")

    @staticmethod
    def shell(device) -> str:
        data = input("enter shell command: ")
        print(device.shell(data))
        return True

    @staticmethod
    def install(device):
        """iterate through the .data/.adb folder, then display apps use index of app to install
        via device.install(app_path) call from ppadb"""
        files = os.listdir(f"{installation}/.data/.adb")
        apps = []
        for x in files:
            if x.endswith(".apk"):
                apps.append(x)
        for x in apps:
            print(f"{apps.index(x)}: {x}")
        try:
            index = input("Enter the index of the app to install")
            device.install(f"{installation}/.data/.adb/{apps[int(index)]}")
            return
        except ValueError:
            print("Please enter the index of the app")
            return

    @staticmethod
    def help(args):
        print("\033[H\033[J")
        print("""[Help For ADB Interface]
    -------------------------------------------------------------------
        connect: Create a remote connection to device from usb
        shell: Runs a shell command
        install: starts the installer
        push: Pushes the selected file in .data/.adb
        cam: Takes a photo with last used camera
        screenshot: Takes a screenshot
        record_screen: records the screen""")
        return

    @staticmethod
    def record_screen(client):
        try:
            print(client.shell(f"screenrecord --time-limit {DatabaseManagment.get()['DURATION']} /sdcard/test.mp4"))
            client.pull("/sdcard/test.mp4", "test.mp4")
            print(client.shell("rm /sdcard/test.mp4"))
            return
        except Exception as e:
            print(e)

    @classmethod
    def code(cls, device):
        if len(devices) < 1:
            return "No devices connected"
        try:
            functs = [cls.shell, cls.help, cls.install, RemoteConnect.adb_connect, cls.push, cls.takePic,
                      cls.screenshot, cls.record_screen]
            inputs = ["shell", "help", "install", "connect", "push", "cam", "screenshot", "record_screen"]
            while True:
                try:
                    data = input("[adb_interface]: ")
                    if "exit" in data:
                        return False
                    for x in inputs:
                        if data in x:
                            functs[inputs.index(x)](device)
                            return True
                    if data not in inputs:
                        IMPORTS.check(data)
                    return True
                except KeyboardInterrupt:
                    return False
        except Exception as e:
            print(str(e))
            print("Error Please enter the index of the device to use")
            return False

try:
    for x in devices:
        serials.append(x.get_serial_no())
        print(f"{devices.index(x)}: {x.get_serial_no()}")
    de = devices[int(input("Enter the index of the device: "))]
    print(f"Using device {de.get_serial_no()}")
    while True:
        if not ADBINTERFACE.code(de):
            break
except KeyboardInterrupt:
    sys.exit()
