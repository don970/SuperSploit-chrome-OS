import os
import subprocess
import traceback
from time import sleep
from .database import DatabaseManagment
from .errors import Error
from .ToStdOut import ToStdout
from threading import Thread


error = Error
write = ToStdout.write

class exploitDetails:
    def __init__(self):
        os.system("clear")
        write("[*] Loading exploit details")
        with open(DatabaseManagment.get()["EXPLOIT"]) as file:
            data = file.read().split("#!#!#!")
            file.close()
        write(f'[*] exploit: {DatabaseManagment.get()["EXPLOIT"]}\nDetails')
        try:
            data = data[1].lstrip('"').rstrip('"')
        except IndexError:
            write(f'[!] Improper format in {DatabaseManagment.get()["EXPLOIT"]}')
            return
        write(f"{data.split('# REQUIRED OPTIONS')[0]}")
        data1 = data.split('# REQUIRED OPTIONS')
        data1 = data1[1].split("\n")
        finds = []
        write('# REQUIRED OPTIONS')
        for x in data1:
            try:
                finds.append(x.split(":")[0].split(" ")[1])
            except IndexError:
                pass
        for k, v in DatabaseManagment.get().items():
            for x in finds:
                if x == k:
                    write(f"{x} = {v}")
        pass



class ExploitHandler:
    def __init__(self, *args):
        types = ["py", "sh", "c"]
        funs = [self.python, self.sh, self.c]
        self.database = DatabaseManagment.get()
        write("[*] Loaded database.")
        self.term = DatabaseManagment.findTerm()
        if DatabaseManagment.getCVE() is not None:
            write(f"[*] CVE number detected using CVE: {DatabaseManagment.getCVE()}")
        write(f"[*] Loaded terminal program: {self.term}")
        Type = self.database["EXPLOIT"].split(".")[len(self.database["EXPLOIT"].split('.')) - 1]
        write(f"[*] Found exploit type {Type}")
        integration = DatabaseManagment.checkIntegration()
        if integration:
            write("[*] SuperSploit integrated exploit detected.")
            if DatabaseManagment.get()["STAGED"]:
                if DatabaseManagment.socketedExploit():
                    write("[*] Remote exploit detected")
                    re = Thread(target=self.remoteExploit)
                    re.start()
                    n = 20
                    while n != 0:
                        write("\033[H\033[J")
                        write(f"Waiting {n} seconds")
                        sleep(1)
                        n -= 1
                else:
                    pass
            else:
                pass
        if Type in types:
            funs[types.index(Type)]()

    def c(self):
        try:
            write("[*] Starting Exploit")
            options = input("[Enter gcc options]: ").split(" ")
            if len(options[0]) > 1:
                cmd = ["gcc"]
                for x in options:
                    cmd.append(x)
                cmd.append(self.database["EXPLOIT"])
                cmd.append("-o")
                cmd.append("exploit")
                data = subprocess.run(cmd, capture_output=True)
            else:
                write("[*] No compiler options set using standard '-o exploit'")
                data = subprocess.run(["gcc", self.database["EXPLOIT"], "-o", "exploit"], capture_output=True)
            data1 = subprocess.run(["chmod", "+x", "exploit"], capture_output=True)
            data2 = subprocess.run(["./exploit"])
            errorPipes = [data, data1]
            for x in errorPipes:
                if len(x.stderr.decode()) > 0:
                    if "implicit declaration of function" in x.stderr.decode():
                        continue
                    if errorPipes.index(x) == 0:
                        write(f'[!] A error occurred while Compiling the exploit {self.database["EXPLOIT"]}')
                        Error(x.stderr)
                        write("[*] cleaning up")
                        subprocess.run(["rm", "exploit"])
                        return
                    write("[!] A permissions error has occurred and was logged to error log in .data/.errors")
                    Error.silent(x.stderr)
                    write("[*] cleaning up")
                    subprocess.run(["rm", "exploit"])
                    return
            write("[*] cleaning up")
            subprocess.run(["rm", "exploit"])
            write("[*] Exploit completed")
        except Exception:
            error(traceback.format_exc())


    def python(self):
        try:
            write("[*] Starting Exploit")
            data = subprocess.run(["python3", self.database["EXPLOIT"]])
            errorPipes = [data]
            for x in errorPipes:
                try:
                    if len(x.stderr.decode()) > 0:
                        write(f"[!] Exploit failed error logged to error log")
                        Error.silent(x.stderr)
                        return
                except AttributeError:
                    write(f"[!] Exploit failed error logged to error log")
                    return
            write("[*] Exploit completed")
        except Exception:
            write(f"[!] Exploit failed error logged to error log")
            error.silent(f"{traceback.format_exc()}")

    def remoteExploit(self):
        try:
            subprocess.run([self.term, "-e", "python3", '"exploits/multi/handler.py"'])
        except Exception as e:
            write(e)

    def sh(self):
        try:
            write("[*] Starting Exploit")
            data = subprocess.run(["bash", self.database["EXPLOIT"]])
            errorPipes = [data]
            for x in errorPipes:
                if len(x.stderr.decode()) > 0:
                    Error(x.stderr)
                    return
            write("[*] Exploit completed")
        except Exception:
            write(f"[!] Exploit failed error logged to error log")
            error.silent(traceback.format_exc())
